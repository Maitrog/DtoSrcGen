using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace DtoSrcGen
{
    [Generator]
    public class DtoGenerator : IIncrementalGenerator
    {
        private readonly List<IAttributeGenerator> _attributeGenerators = new()
        {
            new PickGenerator(),
            new OmitGenerator(),
            new ReadonlyGenerator(),
            new UnionGenerator(),
            new RequiredGenerator(),
        };
        
        private LanguageVersion _languageVersion;

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var languageVersionProvider = context.ParseOptionsProvider
                                                 .Select((options, _) =>
                                                 {
                                                     if (options is CSharpParseOptions csOptions)
                                                         return csOptions.LanguageVersion;

                                                     return LanguageVersion.Default;
                                                 });

            context.RegisterSourceOutput(languageVersionProvider, (productionContext, version) =>
            {
                _languageVersion = version;
            });

            // Debugger.Launch();
            foreach (var generator in _attributeGenerators)
            {
                var targets = context.SyntaxProvider
                                     .ForAttributeWithMetadataName(
                                         generator.AttributeNameWithNamespace,
                                         static (node, _) => node is ClassDeclarationSyntax _,
                                         static (ctx, _) => (INamedTypeSymbol)ctx.TargetSymbol)
                                     .Collect()
                                     .SelectMany(static (list, _) => list.Distinct(SymbolEqualityComparer.Default));
                
                context.RegisterSourceOutput(targets, (sourceProductionContext, typeSymbol) =>
                {
                    generator.Pre(sourceProductionContext, _languageVersion, (INamedTypeSymbol)typeSymbol);
                    var (hintName, sourceText) = GenerateSource(sourceProductionContext, (INamedTypeSymbol)typeSymbol, generator);
                    sourceProductionContext.AddSource(hintName, sourceText);
                });
            }
        }

        private static (string hintName, SourceText sourceText) GenerateSource(
            SourceProductionContext context,
            INamedTypeSymbol typeSymbol,
            IAttributeGenerator attributeGenerator)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using global::System.ComponentModel;");
            sb.AppendLine();
            
            var indent = 0;
            indent = AppendNamespace(sb, typeSymbol, indent);

            var chain = GetContainingTypes(typeSymbol);
            foreach (var symbol in chain)
            {
                AppendTypeStart(sb, symbol, indent);
                indent++;
            }

            // append constructors
            AppendDefaultConstructor(sb, typeSymbol, indent);
            attributeGenerator.AppendConstructors(context, sb, typeSymbol, indent);

            // append properties
            attributeGenerator.AppendProperties(context, sb, typeSymbol, indent);
            
            AppendEndBrackets(indent, sb);

            var hintName = MakeHintName(typeSymbol);
            return (hintName, SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static int AppendNamespace(StringBuilder sb, INamedTypeSymbol typeSymbol, int indent)
        {
            var ns = typeSymbol.ContainingNamespace;

            if (ns is null || ns.IsGlobalNamespace)
                return indent;

            sb.Append("namespace ").Append(ns.ToDisplayString()).AppendLine();
            sb.AppendLine("{");
            indent++;

            return indent;
        }

        private static List<INamedTypeSymbol> GetContainingTypes(INamedTypeSymbol symbol)
        {
            var stack = new Stack<INamedTypeSymbol>();
            var current = symbol;

            while (current is not null)
            {
                stack.Push(current);
                current = current.ContainingType;
            }

            return stack.ToList();
        }

        private static void AppendTypeStart(StringBuilder sb, INamedTypeSymbol symbol, int indent)
        {
            var kind = symbol.IsRecord ? "record" : "class";
            var staticKeyword = symbol.IsStatic ? " static" : "";
            var accessibility = AccessibilityToString(symbol);

            sb.AppendLine($"{GeneratorUtils.Indent(indent)}{accessibility} partial{staticKeyword} {kind} {symbol.Name}{TypeParameters(symbol)}");

            // var constraints = Constraints(symbol, indent);
            // if (constraints.Length > 0)
                // sb.Append(constraints);

            sb.AppendLine($"{GeneratorUtils.Indent(indent)}{{");
        }
        
        private static string AccessibilityToString(ISymbol symbol)
        {
            var acc = symbol.DeclaredAccessibility;

            if (acc == Accessibility.NotApplicable)
                return symbol.ContainingType is null ? "internal" : "private";

            return acc switch
                   {
                       Accessibility.Public => "public",
                       Accessibility.Internal => "internal",
                       Accessibility.Private => "private",
                       Accessibility.Protected => "protected",
                       Accessibility.ProtectedAndInternal => "private protected",
                       Accessibility.ProtectedOrInternal => "protected internal",
                       _ => symbol.ContainingType is null ? "internal" : "private",
                   };
        }
        
        private static string TypeParameters(INamedTypeSymbol symbol)
        {
            if (symbol.TypeParameters.Length == 0) return "";
            return "<" + string.Join(", ", symbol.TypeParameters.Select(tp => tp.Name)) + ">";
        }

        private static string MakeHintName(INamedTypeSymbol symbol)
        {
            var fullName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var sb = new StringBuilder(fullName.Length);

            foreach (var ch in fullName)
            {
                if (char.IsLetterOrDigit(ch) || ch == '_')
                    sb.Append(ch);
                else
                    sb.Append('_');
            }

            sb.Append(".Fields.g.cs");
            return sb.ToString();
        }

        private static void AppendDefaultConstructor(StringBuilder sb, INamedTypeSymbol symbol, int indent)
        {
            var constructor = $"{GeneratorUtils.Indent(indent)}public {symbol.Name}() {{}}";
            
            sb.AppendLine(constructor);
        }

        private static void AppendEndBrackets(int indent, StringBuilder sb)
        {
            indent--;
            sb.AppendLine($"{GeneratorUtils.Indent(indent)}}}");
            indent--;
            sb.AppendLine($"{GeneratorUtils.Indent(indent)}}}");
        }
    }
}